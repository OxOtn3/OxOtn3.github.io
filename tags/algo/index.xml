<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Algo on 耶宵夜</title>
        <link>https://example.com/tags/algo/</link>
        <description>Recent content in Algo on 耶宵夜</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Tue, 05 Apr 2022 18:19:05 +0800</lastBuildDate><atom:link href="https://example.com/tags/algo/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Algo Diary</title>
        <link>https://example.com/p/algo-diary/</link>
        <pubDate>Tue, 05 Apr 2022 18:19:05 +0800</pubDate>
        
        <guid>https://example.com/p/algo-diary/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;medium做多，hard做精，easy做稳&lt;/p&gt;
&lt;p&gt;—3.28 洗澡时有感&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;content&#34;&gt;Content&lt;/h2&gt;
&lt;h3 id=&#34;graph&#34;&gt;Graph&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Dijkstra&lt;/p&gt;
&lt;p&gt;3.30 ~ 4.2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Topological Sort&lt;/p&gt;
&lt;p&gt;4.3 ~ 4.4&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;common&#34;&gt;Common&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Enumeration&lt;/p&gt;
&lt;p&gt;4.5&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Binary Search&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Segment Tree&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;string&#34;&gt;String&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Brute Force&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;KMP&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dp&#34;&gt;DP&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;DP&lt;/li&gt;
&lt;li&gt;Greedy&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;328&#34;&gt;3.28&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/heaters/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;475. 供暖器&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很像我字节二面的算法题&lt;/p&gt;
&lt;p&gt;排序+二分遍历能过&lt;/p&gt;
&lt;h2 id=&#34;329&#34;&gt;3.29&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/max-consecutive-ones-iii/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1004.最大连续1的个数 III&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2024.考试的最大困扰度&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两道一样的滑动窗口&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/checking-existence-of-edge-length-limited-paths/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1697.检查边长度限制的路径是否存在&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一次理解 &lt;code&gt;离线&lt;/code&gt; 和 &lt;code&gt;在线&lt;/code&gt; 的说法&lt;/p&gt;
&lt;p&gt;很巧妙的根据dis和limit排序&lt;/p&gt;
&lt;p&gt;保证dis &amp;lt; limit的情况下只需要用uf判断连通性即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/count-submatrices-with-all-ones/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1504. 统计全 1 子矩形&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;枚举理解了&lt;/p&gt;
&lt;p&gt;单调栈不是很懂&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1277. 统计全为 1 的正方形子矩阵&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这题虽然跟上题很像，但是可以dp，简单很多&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/largest-submatrix-with-rearrangements/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1727. 重新排列后的最大子矩阵&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看上去跟前面两题很像，但思路其实感觉是84/85的思路&lt;/p&gt;
&lt;p&gt;预处理算包括当前位置在内的上方连续的1，然后对每一行排序，遍历，顺便剪枝优化&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/groups-of-strings/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2157. 字符串分组&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一眼就能看出是并查集&lt;/p&gt;
&lt;p&gt;但是比较难想到是二进制枚举，以及替换一个字母的表示&lt;/p&gt;
&lt;p&gt;有一些细节没想明白&lt;/p&gt;
&lt;h2 id=&#34;330&#34;&gt;3.30&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1606. 找到处理最多请求的服务器&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;几乎没有思路，最后只能想到可能用优先队列，然后还是不知道怎么做&lt;/p&gt;
&lt;p&gt;维护两个pq，分别根据编号维护空闲服务器，根据结束时间维护工作中服务器&lt;/p&gt;
&lt;p&gt;很巧妙的用了 &lt;code&gt;i + (idx - i) % k&lt;/code&gt; 入队，并且这里还用到了python负数取模变成同余的非负数的性质，&lt;/p&gt;
&lt;p&gt;别的语言应该是 &lt;code&gt;i + ((idx - i) % k + k) % k&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;目的其实都是一样的，保证得到的是一个不小于 i 的且与 id 同余的数，从而能够保证当前轮次以及下一轮次能够按照服务器编号顺序接受请求&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/network-delay-time/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;743. 网络延迟时间&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比较经典的Dijkstra&lt;/p&gt;
&lt;p&gt;矩阵枚举和优先队列两种写法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1368. 使网格图至少有一条有效路径的最小代价&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然知道要用Dijkstra但是读完题根本想不到，看完题解才明白&lt;/p&gt;
&lt;p&gt;实际上就是顺着箭头的weight=0，变换方向weight=1&lt;/p&gt;
&lt;p&gt;明白这一点之后就是板子题了&lt;/p&gt;
&lt;p&gt;另外学习了一种 &lt;code&gt;0-1 广度优先搜索&lt;/code&gt; ，核心就是双端队列&lt;/p&gt;
&lt;p&gt;weight为0的从队首入队，为1从队尾入队&lt;/p&gt;
&lt;p&gt;这样就保证从原点开始的距离单调增&lt;/p&gt;
&lt;p&gt;（可以拓展到图中只有两种weighta, b，a!=b 的情况&lt;/p&gt;
&lt;p&gt;写法其实和dij类似&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/minimum-weighted-subgraph-with-the-required-paths/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2203. 得到要求路径的最小带权子图&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;周赛没写出来的题hhh&lt;/p&gt;
&lt;p&gt;主要是思路，能想到枚举相交点就很好解决了&lt;/p&gt;
&lt;p&gt;想到了就是板子题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/path-with-maximum-probability/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1514. 概率最大的路径&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;权重变成概率&lt;/p&gt;
&lt;p&gt;dij板子题&lt;/p&gt;
&lt;p&gt;唯一有点坑就是python没有大顶堆，得用 &lt;code&gt;heappush(q, -elem)&lt;/code&gt; 和 &lt;code&gt;-heappop(q)&lt;/code&gt; 实现&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/number-of-ways-to-arrive-at-destination/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1976. 到达目的地的方案数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一眼dij&lt;/p&gt;
&lt;p&gt;但是求方案数不太会，学习了一下&lt;/p&gt;
&lt;p&gt;求出最短路之后反推就行，记得用@cache优化&lt;/p&gt;
&lt;h2 id=&#34;331&#34;&gt;3.31&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/self-dividing-numbers/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;728. 自除数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;暴力，没啥好说的&lt;/p&gt;
&lt;p&gt;第一次拿到每月打卡勋章hhh&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1786. 从第一个节点出发到最后一个节点的受限路径数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始题意没读懂，理解了半天&lt;/p&gt;
&lt;p&gt;dij，然后反推，跟1976很像，只是反推的条件不同&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/reachable-nodes-in-subdivided-graph/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;882. 细分图中的可到达结点&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自己思考做出来了hard，很开心哈哈&lt;/p&gt;
&lt;p&gt;核心还是先dij算出最小距离（weight为cnt + 1），之后遍历边，根据边的两点分别判断，最后加上可达的点即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;787. K 站中转内最便宜的航班&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;套完dij之后就不知道该怎么做了，主要是k的限制，看题解学习了一下&lt;/p&gt;
&lt;p&gt;dist[i] -&amp;gt; dist[i] [j] ，其实就是dp思想&lt;/p&gt;
&lt;p&gt;之后相应改一改dist就可以了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/minimum-cost-to-reach-destination-in-time/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1928. 规定时间内到达终点的最小花费&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跟787其实一样&lt;/p&gt;
&lt;p&gt;dist -&amp;gt; cost&lt;/p&gt;
&lt;p&gt;k -&amp;gt; max_time&lt;/p&gt;
&lt;p&gt;Dij + dp&lt;/p&gt;
&lt;h2 id=&#34;41&#34;&gt;4.1&lt;/h2&gt;
&lt;p&gt;Happy April Fool&amp;rsquo;s Day!&lt;/p&gt;
&lt;p&gt;晚上才开始刷题hhh&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/array-of-doubled-pairs/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;954. 二倍数对数组&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始想的排序+二分，另外维护一个记录，细节好像比较麻烦（其实是不会写二分&lt;/p&gt;
&lt;p&gt;后面想到了pq+dict，思路很清楚，但是由于python处理堆比较麻烦，写了40多行，还好一次ac&lt;/p&gt;
&lt;p&gt;看了一下题解，只能说方向是对的&lt;/p&gt;
&lt;p&gt;直接维护dict（用Counter，然后从绝对值小的开始判断即可&lt;/p&gt;
&lt;p&gt;看题解还可以用拓扑排序做，记个TODO，刷完dij来再做一次&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/maximum-compatibility-score-sum/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1947. 最大兼容性评分和&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;毫无思路，看了题解之后做的，做完还是不知道tag里的dij哪来的&lt;/p&gt;
&lt;p&gt;先预处理出每个学生对应每个老师的得分，&lt;/p&gt;
&lt;p&gt;之后由于数据量不大，想到二进制枚举，0/1代表当前老师是否已经被选，&lt;/p&gt;
&lt;p&gt;接着需要记录状态转移，即当前枚举bit下最大得分，所以用了dp数组，&lt;/p&gt;
&lt;p&gt;而且需要当前位为1才能进状态转移，因为是根据这个位不为1的状态进行转移的&lt;/p&gt;
&lt;p&gt;有个比较tricky的地方，转移的时候要知道当前学生编号为c-1，其实就是因为已经当前已经有c-1个导师被选中了，学生和导师是一一对应的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/minimum-xor-sum-of-two-arrays/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1879. 两个数组最小的异或值之和&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和1947几乎完全一样，唯一不同是dp数组初始化，以及需要注意base case&lt;/p&gt;
&lt;p&gt;预处理+ 二进制枚举+dp&lt;/p&gt;
&lt;h2 id=&#34;42&#34;&gt;4.2&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/strong-password-checker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;420. 强密码检验器&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;模拟，想不出来，就看答案了&lt;/p&gt;
&lt;p&gt;看了还是不太会hhh，先放一放吧&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/swim-in-rising-water/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;778. 水位上升的泳池中游泳&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始看到tag，往dij方向想，没想出来&lt;/p&gt;
&lt;p&gt;看到题解后用bfs+pq很简单做出来&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/min-cost-to-connect-all-points/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1584. 连接所有点的最小费用&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;mst板子题&lt;/p&gt;
&lt;p&gt;用kruskal怎么写都不对，一开始发现边没从j+1开始造，改了发现还是不对，麻了&lt;/p&gt;
&lt;p&gt;prim过了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/trapping-rain-water-ii/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;407. 接雨水 II&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始的思路是模仿二维的，维护四个方向的最小值，取最小值减，但是没有想具体实现，感觉比较麻烦&lt;/p&gt;
&lt;p&gt;其实思路是对的，实现用最小堆+visited&lt;/p&gt;
&lt;p&gt;首先边上一圈肯定接不到雨水，预处理，记录已经visit并且入堆，&lt;/p&gt;
&lt;p&gt;之后循环取堆中最小的进行四周遍历，能填就往里填，再入堆（注意入堆的是接过雨水之后的高度，可能不变也可能变高&lt;/p&gt;
&lt;p&gt;双周赛a3道，最后一题拓展KMP板子，不会&lt;/p&gt;
&lt;h2 id=&#34;43&#34;&gt;4.3&lt;/h2&gt;
&lt;p&gt;周赛第一次AKhhh&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;744. 寻找比目标字母大的最小字母&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;模拟就行，还可以二分&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/course-schedule-ii/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;210. 课程表 II&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和207类似，拓扑排序，顺便记录一下就行&lt;/p&gt;
&lt;p&gt;拓扑排序其实就是维护入度+bfs&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/find-eventual-safe-states/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;802. 找到最终的安全状态&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;建立反图再拓扑排序即可&lt;/p&gt;
&lt;p&gt;看题解学习了dfs+三色标记，维护一个记录节点颜色数组，分别代表状态为未访问，正在访问的栈中/在环上，已访问过且不在环上，&lt;/p&gt;
&lt;p&gt;对每个点进行dfs即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/minimum-height-trees/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;310. 最小高度树&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始想的统计度，最小的作为根节点，发现不太行&lt;/p&gt;
&lt;p&gt;看了题解，其实思路差不多，也是拓扑排序bfs的板子&lt;/p&gt;
&lt;p&gt;维护degree表，双向的图，用队列bfs，度为1的入队&lt;/p&gt;
&lt;p&gt;其实最后只可能剩下1/2个可能的根节点&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1203. 项目管理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了拓扑没什么思路，无从下手&lt;/p&gt;
&lt;p&gt;看了题解，思路真的牛逼&lt;/p&gt;
&lt;p&gt;双重拓扑排序，先根据组的关系排一次，得到组的顺序，再根据每一组内的项目进行排序&lt;/p&gt;
&lt;p&gt;有几个比较tricky的地方：一是没有组的需要改成不同的组号，维护变量遍历改即可，&lt;/p&gt;
&lt;p&gt;二是需要注意在不同组的时候，需要根据项目建图，而不是根据组建图，vice versa&lt;/p&gt;
&lt;p&gt;其间任何一次拓扑排序后结果不正确（有环，都可以直接return空&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/course-schedule-iv/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1462. 课程表 IV&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;板子题，另外维护一个前置节点即可&lt;/p&gt;
&lt;p&gt;注意python的set取交集用 |&lt;/p&gt;
&lt;p&gt;看题解发现了用dfs + @cache，不得不说python的@cache真的赖皮&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/strange-printer-ii/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1591. 奇怪的打印机 II&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;完全没有思路&lt;/p&gt;
&lt;p&gt;看了答案才知道为什么用拓扑排序&lt;/p&gt;
&lt;p&gt;对每种颜色进行遍历，确定最大范围，在这个颜色范围内，不是这个颜色，说明在涂完这个颜色后，又新涂了当前颜色，&lt;/p&gt;
&lt;p&gt;所以可以理解为一种先后关系，原来的颜色 -&amp;gt; 现在的颜色，所以可以建图，维护入度&lt;/p&gt;
&lt;p&gt;题目中限定数字范围为&amp;lt;=60，所以开61的空间就好&lt;/p&gt;
&lt;p&gt;之后就是板子题了&lt;/p&gt;
&lt;p&gt;犯了个很sb的错误，找了半天bug，心态崩了&lt;/p&gt;
&lt;h2 id=&#34;44&#34;&gt;4.4&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/range-sum-query-mutable/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;307. 区域和检索 - 数组可修改&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;树状数组/线段树 板子题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/rank-transform-of-a-matrix/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1632. 矩阵转换后的秩&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;真困难题&lt;/p&gt;
&lt;p&gt;因为只考虑每行/列的相对关系，所以可以用拓扑排序&lt;/p&gt;
&lt;p&gt;但是写到最后出了点问题，因为当行/列元素相同时需要保证该元素的最终值为相等元素的值中最大的那一个，想了一下只能想到并查集，感觉很麻烦，就看答案了&lt;/p&gt;
&lt;p&gt;结果一看真是并查集&lt;/p&gt;
&lt;p&gt;不想改了，cv&lt;/p&gt;
&lt;p&gt;（看了一下是codeforces div1的c题原题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1857. 有向图中最大颜色值&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;困难的点在于记录颜色值，没什么思路&lt;/p&gt;
&lt;p&gt;看了答案，其实开个数组记录就可以了（或者说是dp&lt;/p&gt;
&lt;p&gt;dp[i] [j]：到i点为止，颜色j的最大值，然后在拓扑排序的过程中更新状态即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/parallel-courses-iii/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2050. 并行课程 III&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跟1857很像，拓扑+dp维护所需最大时间即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/find-all-possible-recipes-from-given-supplies/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2115. 从给定原材料中找到所有可以做出的菜&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很早之前周赛的一道题目，当时还不怎么会写拓扑排序hhh&lt;/p&gt;
&lt;p&gt;思路很简单，但是比较坑的一点就是ingredients里面可能在recipes和supplies都没出现过，我的处理是只加入度不加边&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/groups-of-strings/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2157. 字符串分组&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;真困难题&lt;/p&gt;
&lt;p&gt;3.29做过的题，当时没做完，又做了一下，应该是之前做过几道二进制枚举题目的原因，完全理解了解题思路&lt;/p&gt;
&lt;p&gt;由于 &lt;code&gt;只考虑s1和s2的集合&lt;/code&gt; ，也就是说出现顺序无关，并且每个字母最多出现一次，所以可以用二进制位表示，&lt;/p&gt;
&lt;p&gt;为了得到答案的分组数和最大个数，需要用 &lt;code&gt;并查集&lt;/code&gt; ，&lt;/p&gt;
&lt;p&gt;那么删除/添加一个字母，分别对应异或当前位，由1变0和由0变1，&lt;/p&gt;
&lt;p&gt;替换一个字母，实际上是删除一个字母，然后再次遍历，并且只能是添加一个字母，&lt;/p&gt;
&lt;p&gt;其中可以维护一个set来快速判断是否存在于word，以及record记录words中对应的并查集parent&lt;/p&gt;
&lt;p&gt;最后9秒多过了，差点TLE了，看来评论说python卡常是真的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/maximum-employees-to-be-invited-to-a-meeting/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2127. 参加会议的最多员工数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;真困难题&lt;/p&gt;
&lt;p&gt;pending一下，不太会&lt;/p&gt;
&lt;p&gt;题解说是内向基环树&lt;/p&gt;
&lt;p&gt;看了群主的视频，思路很清晰了，主要是分析部分：&lt;/p&gt;
&lt;p&gt;分析可得，对于图的每一个连通部分，有两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;有环，且环上的点个数 &amp;gt;= 3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有环，且环上的点个数 == 2&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于情况1，最大满足条件的个数只能为环上的个数，因为此时每个点的两边都已经定了&lt;/p&gt;
&lt;p&gt;对于情况2，此时图的形状是两元环+每个顶点延伸的边，&lt;/p&gt;
&lt;p&gt;此时最大满足条件个数可以加上其他连通部分的情况2下的点数总和，&lt;/p&gt;
&lt;p&gt;因为对于情况2中的顶点，无论是二元环上的点还是延伸边上的点，都还有另一边空着，&lt;/p&gt;
&lt;p&gt;所以拓扑排序时，为每个点维护变量记录向外延展的个数，&lt;/p&gt;
&lt;p&gt;维护一个visited数组，排序完后visited[i] = False为环上点，再对每一个连通分量进行遍历，择优&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/jC7MId/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;剑指 Offer II 051. 节点之和最大的路径&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;做过的题还是不会做&lt;/p&gt;
&lt;p&gt;果然纯靠理解做和靠刷题堆砌的结果还是有差距的，说到底还是我太菜了&lt;/p&gt;
&lt;p&gt;后序遍历就可以了，注意更新res的值和返回的值不一样，更新的值可以是l+r+root.val，因为在同一条路径上，但返回只能返回最大值了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/NYBBNL/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;剑指 Offer II 052. 展平二叉搜索树&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要是一开始用一个dummy，然后维护一个pre&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/P5rCT8/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;剑指 Offer II 053. 二叉搜索树中的中序后继&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;利用好二叉搜索树性质中序遍历就可以了&lt;/p&gt;
&lt;p&gt;应该是简单题。。&lt;/p&gt;
&lt;h2 id=&#34;45&#34;&gt;4.5&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;762. 二进制表示中质数个计算置位&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;暴力就行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/lexicographically-smallest-string-after-applying-operations/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1625. 执行操作后字典序最小的字符串&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以为有什么厉害的解法，结果居然就是枚举&lt;/p&gt;
&lt;p&gt;先累加遍历，再轮转遍历（反过来也行，然后取最小&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;795. 区间子数组个数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题解的思路很精妙：&lt;/p&gt;
&lt;p&gt;小于等于right的子数组数 - 小于等于left - 1的子数组数 = [left, right]的子数组数，&lt;/p&gt;
&lt;p&gt;所以写个count函数计算小于等于k的子数组数就可以了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1737. 满足三条件之一需改变的最少字符数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;太菜了，根本没思路，答案思路：&lt;/p&gt;
&lt;p&gt;分别统计ab中每个字母出现次数，然后对i进行枚举，使得a中每个字母都小于等于i，b中每个字母都大于i，&lt;/p&gt;
&lt;p&gt;这样分别对应情况1和2，&lt;/p&gt;
&lt;p&gt;有个tricky的点，枚举中a是可以的，但z不行，因为字母不能大于z，&lt;/p&gt;
&lt;p&gt;情况3通过枚举i，使得a，b每个字母都为i，需要的操作数也就是ab的长度和减去i在ab中分别出现的次数，&lt;/p&gt;
&lt;p&gt;最后择优即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/detect-squares/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2013. 检测正方形&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用counter或者hashmap记录一下，每次枚举遍历就可了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/search-insert-position/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;35. 搜索插入位置&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二分，水一题hhh&lt;/p&gt;
&lt;p&gt;&amp;ndash;600啦，暂时不想刷了hh&amp;ndash;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
