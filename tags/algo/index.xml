<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Algo on 耶宵夜</title>
        <link>https://example.com/tags/algo/</link>
        <description>Recent content in Algo on 耶宵夜</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Tue, 05 Apr 2022 18:19:05 +0800</lastBuildDate><atom:link href="https://example.com/tags/algo/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Algo Diary</title>
        <link>https://example.com/p/algo-diary/</link>
        <pubDate>Tue, 05 Apr 2022 18:19:05 +0800</pubDate>
        
        <guid>https://example.com/p/algo-diary/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;medium做多，hard做精，easy做稳&lt;/p&gt;
&lt;p&gt;—3.28 洗澡时有感&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;content&#34;&gt;Content&lt;/h2&gt;
&lt;h3 id=&#34;graph&#34;&gt;Graph&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Dijkstra&lt;/p&gt;
&lt;p&gt;3.30 ~ 4.2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Topological Sort&lt;/p&gt;
&lt;p&gt;4.3 ~ 4.4&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;common&#34;&gt;Common&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Enumeration&lt;/p&gt;
&lt;p&gt;4.5&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Binary Search&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Segment Tree&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;string&#34;&gt;String&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Brute Force&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;KMP&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dp&#34;&gt;DP&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;DP&lt;/li&gt;
&lt;li&gt;Greedy&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;328&#34;&gt;3.28&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/heaters/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;475. 供暖器&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很像我字节二面的算法题&lt;/p&gt;
&lt;p&gt;排序+二分遍历能过&lt;/p&gt;
&lt;h2 id=&#34;329&#34;&gt;3.29&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/max-consecutive-ones-iii/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1004.最大连续1的个数 III&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2024.考试的最大困扰度&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两道一样的滑动窗口&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/checking-existence-of-edge-length-limited-paths/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1697.检查边长度限制的路径是否存在&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一次理解 &lt;code&gt;离线&lt;/code&gt; 和 &lt;code&gt;在线&lt;/code&gt; 的说法&lt;/p&gt;
&lt;p&gt;很巧妙的根据dis和limit排序&lt;/p&gt;
&lt;p&gt;保证dis &amp;lt; limit的情况下只需要用uf判断连通性即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/count-submatrices-with-all-ones/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1504. 统计全 1 子矩形&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;枚举理解了&lt;/p&gt;
&lt;p&gt;单调栈不是很懂&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1277. 统计全为 1 的正方形子矩阵&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这题虽然跟上题很像，但是可以dp，简单很多&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/largest-submatrix-with-rearrangements/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1727. 重新排列后的最大子矩阵&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看上去跟前面两题很像，但思路其实感觉是84/85的思路&lt;/p&gt;
&lt;p&gt;预处理算包括当前位置在内的上方连续的1，然后对每一行排序，遍历，顺便剪枝优化&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/groups-of-strings/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2157. 字符串分组&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一眼就能看出是并查集&lt;/p&gt;
&lt;p&gt;但是比较难想到是二进制枚举，以及替换一个字母的表示&lt;/p&gt;
&lt;p&gt;有一些细节没想明白&lt;/p&gt;
&lt;h2 id=&#34;330&#34;&gt;3.30&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1606. 找到处理最多请求的服务器&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;几乎没有思路，最后只能想到可能用优先队列，然后还是不知道怎么做&lt;/p&gt;
&lt;p&gt;维护两个pq，分别根据编号维护空闲服务器，根据结束时间维护工作中服务器&lt;/p&gt;
&lt;p&gt;很巧妙的用了 &lt;code&gt;i + (idx - i) % k&lt;/code&gt; 入队，并且这里还用到了python负数取模变成同余的非负数的性质，&lt;/p&gt;
&lt;p&gt;别的语言应该是 &lt;code&gt;i + ((idx - i) % k + k) % k&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;目的其实都是一样的，保证得到的是一个不小于 i 的且与 id 同余的数，从而能够保证当前轮次以及下一轮次能够按照服务器编号顺序接受请求&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/network-delay-time/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;743. 网络延迟时间&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比较经典的Dijkstra&lt;/p&gt;
&lt;p&gt;矩阵枚举和优先队列两种写法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1368. 使网格图至少有一条有效路径的最小代价&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然知道要用Dijkstra但是读完题根本想不到，看完题解才明白&lt;/p&gt;
&lt;p&gt;实际上就是顺着箭头的weight=0，变换方向weight=1&lt;/p&gt;
&lt;p&gt;明白这一点之后就是板子题了&lt;/p&gt;
&lt;p&gt;另外学习了一种 &lt;code&gt;0-1 广度优先搜索&lt;/code&gt; ，核心就是双端队列&lt;/p&gt;
&lt;p&gt;weight为0的从队首入队，为1从队尾入队&lt;/p&gt;
&lt;p&gt;这样就保证从原点开始的距离单调增&lt;/p&gt;
&lt;p&gt;（可以拓展到图中只有两种weighta, b，a!=b 的情况&lt;/p&gt;
&lt;p&gt;写法其实和dij类似&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/minimum-weighted-subgraph-with-the-required-paths/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2203. 得到要求路径的最小带权子图&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;周赛没写出来的题hhh&lt;/p&gt;
&lt;p&gt;主要是思路，能想到枚举相交点就很好解决了&lt;/p&gt;
&lt;p&gt;想到了就是板子题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/path-with-maximum-probability/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1514. 概率最大的路径&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;权重变成概率&lt;/p&gt;
&lt;p&gt;dij板子题&lt;/p&gt;
&lt;p&gt;唯一有点坑就是python没有大顶堆，得用 &lt;code&gt;heappush(q, -elem)&lt;/code&gt; 和 &lt;code&gt;-heappop(q)&lt;/code&gt; 实现&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/number-of-ways-to-arrive-at-destination/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1976. 到达目的地的方案数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一眼dij&lt;/p&gt;
&lt;p&gt;但是求方案数不太会，学习了一下&lt;/p&gt;
&lt;p&gt;求出最短路之后反推就行，记得用@cache优化&lt;/p&gt;
&lt;h2 id=&#34;331&#34;&gt;3.31&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/self-dividing-numbers/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;728. 自除数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;暴力，没啥好说的&lt;/p&gt;
&lt;p&gt;第一次拿到每月打卡勋章hhh&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1786. 从第一个节点出发到最后一个节点的受限路径数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始题意没读懂，理解了半天&lt;/p&gt;
&lt;p&gt;dij，然后反推，跟1976很像，只是反推的条件不同&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/reachable-nodes-in-subdivided-graph/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;882. 细分图中的可到达结点&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自己思考做出来了hard，很开心哈哈&lt;/p&gt;
&lt;p&gt;核心还是先dij算出最小距离（weight为cnt + 1），之后遍历边，根据边的两点分别判断，最后加上可达的点即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;787. K 站中转内最便宜的航班&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;套完dij之后就不知道该怎么做了，主要是k的限制，看题解学习了一下&lt;/p&gt;
&lt;p&gt;dist[i] -&amp;gt; dist[i] [j] ，其实就是dp思想&lt;/p&gt;
&lt;p&gt;之后相应改一改dist就可以了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/minimum-cost-to-reach-destination-in-time/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1928. 规定时间内到达终点的最小花费&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跟787其实一样&lt;/p&gt;
&lt;p&gt;dist -&amp;gt; cost&lt;/p&gt;
&lt;p&gt;k -&amp;gt; max_time&lt;/p&gt;
&lt;p&gt;Dij + dp&lt;/p&gt;
&lt;h2 id=&#34;41&#34;&gt;4.1&lt;/h2&gt;
&lt;p&gt;Happy April Fool&amp;rsquo;s Day!&lt;/p&gt;
&lt;p&gt;晚上才开始刷题hhh&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/array-of-doubled-pairs/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;954. 二倍数对数组&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始想的排序+二分，另外维护一个记录，细节好像比较麻烦（其实是不会写二分&lt;/p&gt;
&lt;p&gt;后面想到了pq+dict，思路很清楚，但是由于python处理堆比较麻烦，写了40多行，还好一次ac&lt;/p&gt;
&lt;p&gt;看了一下题解，只能说方向是对的&lt;/p&gt;
&lt;p&gt;直接维护dict（用Counter，然后从绝对值小的开始判断即可&lt;/p&gt;
&lt;p&gt;看题解还可以用拓扑排序做，记个TODO，刷完dij来再做一次&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/maximum-compatibility-score-sum/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1947. 最大兼容性评分和&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;毫无思路，看了题解之后做的，做完还是不知道tag里的dij哪来的&lt;/p&gt;
&lt;p&gt;先预处理出每个学生对应每个老师的得分，&lt;/p&gt;
&lt;p&gt;之后由于数据量不大，想到二进制枚举，0/1代表当前老师是否已经被选，&lt;/p&gt;
&lt;p&gt;接着需要记录状态转移，即当前枚举bit下最大得分，所以用了dp数组，&lt;/p&gt;
&lt;p&gt;而且需要当前位为1才能进状态转移，因为是根据这个位不为1的状态进行转移的&lt;/p&gt;
&lt;p&gt;有个比较tricky的地方，转移的时候要知道当前学生编号为c-1，其实就是因为已经当前已经有c-1个导师被选中了，学生和导师是一一对应的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/minimum-xor-sum-of-two-arrays/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1879. 两个数组最小的异或值之和&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和1947几乎完全一样，唯一不同是dp数组初始化，以及需要注意base case&lt;/p&gt;
&lt;p&gt;预处理+ 二进制枚举+dp&lt;/p&gt;
&lt;h2 id=&#34;42&#34;&gt;4.2&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/strong-password-checker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;420. 强密码检验器&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;模拟，想不出来，就看答案了&lt;/p&gt;
&lt;p&gt;看了还是不太会hhh，先放一放吧&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/swim-in-rising-water/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;778. 水位上升的泳池中游泳&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始看到tag，往dij方向想，没想出来&lt;/p&gt;
&lt;p&gt;看到题解后用bfs+pq很简单做出来&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/min-cost-to-connect-all-points/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1584. 连接所有点的最小费用&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;mst板子题&lt;/p&gt;
&lt;p&gt;用kruskal怎么写都不对，一开始发现边没从j+1开始造，改了发现还是不对，麻了&lt;/p&gt;
&lt;p&gt;prim过了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/trapping-rain-water-ii/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;407. 接雨水 II&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始的思路是模仿二维的，维护四个方向的最小值，取最小值减，但是没有想具体实现，感觉比较麻烦&lt;/p&gt;
&lt;p&gt;其实思路是对的，实现用最小堆+visited&lt;/p&gt;
&lt;p&gt;首先边上一圈肯定接不到雨水，预处理，记录已经visit并且入堆，&lt;/p&gt;
&lt;p&gt;之后循环取堆中最小的进行四周遍历，能填就往里填，再入堆（注意入堆的是接过雨水之后的高度，可能不变也可能变高&lt;/p&gt;
&lt;p&gt;双周赛a3道，最后一题拓展KMP板子，不会&lt;/p&gt;
&lt;h2 id=&#34;43&#34;&gt;4.3&lt;/h2&gt;
&lt;p&gt;周赛第一次AKhhh&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;744. 寻找比目标字母大的最小字母&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;模拟就行，还可以二分&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/course-schedule-ii/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;210. 课程表 II&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和207类似，拓扑排序，顺便记录一下就行&lt;/p&gt;
&lt;p&gt;拓扑排序其实就是维护入度+bfs&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/find-eventual-safe-states/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;802. 找到最终的安全状态&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;建立反图再拓扑排序即可&lt;/p&gt;
&lt;p&gt;看题解学习了dfs+三色标记，维护一个记录节点颜色数组，分别代表状态为未访问，正在访问的栈中/在环上，已访问过且不在环上，&lt;/p&gt;
&lt;p&gt;对每个点进行dfs即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/minimum-height-trees/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;310. 最小高度树&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始想的统计度，最小的作为根节点，发现不太行&lt;/p&gt;
&lt;p&gt;看了题解，其实思路差不多，也是拓扑排序bfs的板子&lt;/p&gt;
&lt;p&gt;维护degree表，双向的图，用队列bfs，度为1的入队&lt;/p&gt;
&lt;p&gt;其实最后只可能剩下1/2个可能的根节点&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1203. 项目管理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了拓扑没什么思路，无从下手&lt;/p&gt;
&lt;p&gt;看了题解，思路真的牛逼&lt;/p&gt;
&lt;p&gt;双重拓扑排序，先根据组的关系排一次，得到组的顺序，再根据每一组内的项目进行排序&lt;/p&gt;
&lt;p&gt;有几个比较tricky的地方：一是没有组的需要改成不同的组号，维护变量遍历改即可，&lt;/p&gt;
&lt;p&gt;二是需要注意在不同组的时候，需要根据项目建图，而不是根据组建图，vice versa&lt;/p&gt;
&lt;p&gt;其间任何一次拓扑排序后结果不正确（有环，都可以直接return空&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/course-schedule-iv/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1462. 课程表 IV&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;板子题，另外维护一个前置节点即可&lt;/p&gt;
&lt;p&gt;注意python的set取交集用 |&lt;/p&gt;
&lt;p&gt;看题解发现了用dfs + @cache，不得不说python的@cache真的赖皮&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/strange-printer-ii/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1591. 奇怪的打印机 II&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;完全没有思路&lt;/p&gt;
&lt;p&gt;看了答案才知道为什么用拓扑排序&lt;/p&gt;
&lt;p&gt;对每种颜色进行遍历，确定最大范围，在这个颜色范围内，不是这个颜色，说明在涂完这个颜色后，又新涂了当前颜色，&lt;/p&gt;
&lt;p&gt;所以可以理解为一种先后关系，原来的颜色 -&amp;gt; 现在的颜色，所以可以建图，维护入度&lt;/p&gt;
&lt;p&gt;题目中限定数字范围为&amp;lt;=60，所以开61的空间就好&lt;/p&gt;
&lt;p&gt;之后就是板子题了&lt;/p&gt;
&lt;p&gt;犯了个很sb的错误，找了半天bug，心态崩了&lt;/p&gt;
&lt;h2 id=&#34;44&#34;&gt;4.4&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/range-sum-query-mutable/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;307. 区域和检索 - 数组可修改&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;树状数组/线段树 板子题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/rank-transform-of-a-matrix/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1632. 矩阵转换后的秩&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;真困难题&lt;/p&gt;
&lt;p&gt;因为只考虑每行/列的相对关系，所以可以用拓扑排序&lt;/p&gt;
&lt;p&gt;但是写到最后出了点问题，因为当行/列元素相同时需要保证该元素的最终值为相等元素的值中最大的那一个，想了一下只能想到并查集，感觉很麻烦，就看答案了&lt;/p&gt;
&lt;p&gt;结果一看真是并查集&lt;/p&gt;
&lt;p&gt;不想改了，cv&lt;/p&gt;
&lt;p&gt;（看了一下是codeforces div1的c题原题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1857. 有向图中最大颜色值&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;困难的点在于记录颜色值，没什么思路&lt;/p&gt;
&lt;p&gt;看了答案，其实开个数组记录就可以了（或者说是dp&lt;/p&gt;
&lt;p&gt;dp[i] [j]：到i点为止，颜色j的最大值，然后在拓扑排序的过程中更新状态即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/parallel-courses-iii/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2050. 并行课程 III&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跟1857很像，拓扑+dp维护所需最大时间即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/find-all-possible-recipes-from-given-supplies/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2115. 从给定原材料中找到所有可以做出的菜&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很早之前周赛的一道题目，当时还不怎么会写拓扑排序hhh&lt;/p&gt;
&lt;p&gt;思路很简单，但是比较坑的一点就是ingredients里面可能在recipes和supplies都没出现过，我的处理是只加入度不加边&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/groups-of-strings/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2157. 字符串分组&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;真困难题&lt;/p&gt;
&lt;p&gt;3.29做过的题，当时没做完，又做了一下，应该是之前做过几道二进制枚举题目的原因，完全理解了解题思路&lt;/p&gt;
&lt;p&gt;由于 &lt;code&gt;只考虑s1和s2的集合&lt;/code&gt; ，也就是说出现顺序无关，并且每个字母最多出现一次，所以可以用二进制位表示，&lt;/p&gt;
&lt;p&gt;为了得到答案的分组数和最大个数，需要用 &lt;code&gt;并查集&lt;/code&gt; ，&lt;/p&gt;
&lt;p&gt;那么删除/添加一个字母，分别对应异或当前位，由1变0和由0变1，&lt;/p&gt;
&lt;p&gt;替换一个字母，实际上是删除一个字母，然后再次遍历，并且只能是添加一个字母，&lt;/p&gt;
&lt;p&gt;其中可以维护一个set来快速判断是否存在于word，以及record记录words中对应的并查集parent&lt;/p&gt;
&lt;p&gt;最后9秒多过了，差点TLE了，看来评论说python卡常是真的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/maximum-employees-to-be-invited-to-a-meeting/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2127. 参加会议的最多员工数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;真困难题&lt;/p&gt;
&lt;p&gt;pending一下，不太会&lt;/p&gt;
&lt;p&gt;题解说是内向基环树&lt;/p&gt;
&lt;p&gt;看了群主的视频，思路很清晰了，主要是分析部分：&lt;/p&gt;
&lt;p&gt;分析可得，对于图的每一个连通部分，有两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;有环，且环上的点个数 &amp;gt;= 3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有环，且环上的点个数 == 2&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于情况1，最大满足条件的个数只能为环上的个数，因为此时每个点的两边都已经定了&lt;/p&gt;
&lt;p&gt;对于情况2，此时图的形状是两元环+每个顶点延伸的边，&lt;/p&gt;
&lt;p&gt;此时最大满足条件个数可以加上其他连通部分的情况2下的点数总和，&lt;/p&gt;
&lt;p&gt;因为对于情况2中的顶点，无论是二元环上的点还是延伸边上的点，都还有另一边空着，&lt;/p&gt;
&lt;p&gt;所以拓扑排序时，为每个点维护变量记录向外延展的个数，&lt;/p&gt;
&lt;p&gt;维护一个visited数组，排序完后visited[i] = False为环上点，再对每一个连通分量进行遍历，择优&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/jC7MId/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;剑指 Offer II 051. 节点之和最大的路径&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;做过的题还是不会做&lt;/p&gt;
&lt;p&gt;果然纯靠理解做和靠刷题堆砌的结果还是有差距的，说到底还是我太菜了&lt;/p&gt;
&lt;p&gt;后序遍历就可以了，注意更新res的值和返回的值不一样，更新的值可以是l+r+root.val，因为在同一条路径上，但返回只能返回最大值了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/NYBBNL/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;剑指 Offer II 052. 展平二叉搜索树&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要是一开始用一个dummy，然后维护一个pre&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/P5rCT8/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;剑指 Offer II 053. 二叉搜索树中的中序后继&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;利用好二叉搜索树性质中序遍历就可以了&lt;/p&gt;
&lt;p&gt;应该是简单题。。&lt;/p&gt;
&lt;h2 id=&#34;45&#34;&gt;4.5&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;762. 二进制表示中质数个计算置位&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;暴力就行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/lexicographically-smallest-string-after-applying-operations/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1625. 执行操作后字典序最小的字符串&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以为有什么厉害的解法，结果居然就是枚举&lt;/p&gt;
&lt;p&gt;先累加遍历，再轮转遍历（反过来也行，然后取最小&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;795. 区间子数组个数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题解的思路很精妙：&lt;/p&gt;
&lt;p&gt;小于等于right的子数组数 - 小于等于left - 1的子数组数 = [left, right]的子数组数，&lt;/p&gt;
&lt;p&gt;所以写个count函数计算小于等于k的子数组数就可以了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1737. 满足三条件之一需改变的最少字符数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;太菜了，根本没思路，答案思路：&lt;/p&gt;
&lt;p&gt;分别统计ab中每个字母出现次数，然后对i进行枚举，使得a中每个字母都小于等于i，b中每个字母都大于i，&lt;/p&gt;
&lt;p&gt;这样分别对应情况1和2，&lt;/p&gt;
&lt;p&gt;有个tricky的点，枚举中a是可以的，但z不行，因为字母不能大于z，&lt;/p&gt;
&lt;p&gt;情况3通过枚举i，使得a，b每个字母都为i，需要的操作数也就是ab的长度和减去i在ab中分别出现的次数，&lt;/p&gt;
&lt;p&gt;最后择优即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/detect-squares/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2013. 检测正方形&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用counter或者hashmap记录一下，每次枚举遍历就可了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/search-insert-position/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;35. 搜索插入位置&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二分，水一题hhh&lt;/p&gt;
&lt;p&gt;&amp;ndash;600啦，暂时不想刷了hh&amp;ndash;&lt;/p&gt;
&lt;h2 id=&#34;48&#34;&gt;4.8&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/longest-duplicate-substring/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1044. 最长重复子串&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看群主视频，学到了二分的一个小技巧：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mid&lt;/code&gt; 可以写成 &lt;code&gt;mid = left + (right - left) / 2&lt;/code&gt; ，也可以写成&lt;code&gt;mid = right - (right - left) / 2&lt;/code&gt; ，两种可以通过取0取1的边界case选择，防止死循环&lt;/p&gt;
&lt;h2 id=&#34;49&#34;&gt;4.9&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/reaching-points/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;780. 到达终点&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;能想到是逆向思维，但没想到是直接用mod&lt;/p&gt;
&lt;p&gt;用减法会超时&lt;/p&gt;
&lt;p&gt;只要知道 tx &amp;gt; ty 时，直接 tx %= ty 就好了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/sum-of-subarray-minimums/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;907. 子数组的最小值之和&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始想到很多种思路，也想到单调栈了，但没想到具体实现&lt;/p&gt;
&lt;p&gt;其实和84题很像，维护一个单调增栈，当前遍历到的元素小于栈顶元素，说明栈顶元素作为最小值的区间已经确定，累加即可，&lt;/p&gt;
&lt;p&gt;即该元素值 * 左区间长度 * 右区间长度&lt;/p&gt;
&lt;h2 id=&#34;416&#34;&gt;4.16&lt;/h2&gt;
&lt;p&gt;这一周都在忙公司的事还有学校的复习，完全没刷题，直接来双周赛了&lt;/p&gt;
&lt;p&gt;前两题很快，因为真的很简单&lt;/p&gt;
&lt;p&gt;万万没想到第三题卡住了，其实也是个很简单的题目，想复杂了&lt;/p&gt;
&lt;p&gt;因为只有5个面额，每次取款从大到小遍历一下就好了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/maximum-score-of-a-node-sequence/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;6063. 节点序列的最大得分&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第四题确实不会，只能想到枚举点，但是由于是4个点所以需要枚举2次确定两个中心点，&lt;/p&gt;
&lt;p&gt;5e4肯定超时的&lt;/p&gt;
&lt;p&gt;赛后知道可以枚举边，中间边就能确定两个点了，&lt;/p&gt;
&lt;p&gt;之后贪心的选择一下剩下两个点即可，这里可以用heap做，&lt;/p&gt;
&lt;p&gt;整体答案也就20行左右，真的算挺简单的&lt;/p&gt;
&lt;p&gt;第四题的确有一定难度，总共A了300来人，&lt;/p&gt;
&lt;p&gt;其实前三题做的快一点，还是能拿到一个不错的名次的，&lt;/p&gt;
&lt;p&gt;但是第三题卡了很久，还是说明刷题需要坚持&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我也很多次都在想，我刷题到底是为了什么&lt;/p&gt;
&lt;p&gt;如果说一开始是为了面试，其实刷到这个地步，常见的题型该见也都见过了，面试前只需要反复刷两三天，把前面的捡起来就基本上没问题了&lt;/p&gt;
&lt;p&gt;但是我又看到身边非常多的大佬，要么动辄几千题，要么是竞赛选手，这的确给了我不小压力，我也想变得跟他们一样强&lt;/p&gt;
&lt;p&gt;刷到现在，如果说我还有继续刷下去的动力的话，应该是来自于后者&lt;/p&gt;
&lt;p&gt;实际上，我也的确能在刷题中收获快乐，这种快乐来自于自己觉得经过几道几十道的题目的磨练，的确掌握了某些知识，又或者是周赛里面拿到好一点的排名上分，这些都能让我感觉我的努力得到了回报&lt;/p&gt;
&lt;p&gt;那么既然如此，为什么我还会有这样的想法呢，还会犹豫今天是否要刷题，最终还是以各种借口搪塞掉&lt;/p&gt;
&lt;p&gt;哎，我也不知道&lt;/p&gt;
&lt;p&gt;但最起码，AC之后的喜悦是真实的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;417&#34;&gt;4.17&lt;/h2&gt;
&lt;p&gt;周赛打完&lt;/p&gt;
&lt;p&gt;补充了todo&lt;/p&gt;
&lt;h2 id=&#34;423&#34;&gt;4.23&lt;/h2&gt;
&lt;p&gt;晚上做了字节的模拟笔试，前三题都挺简单的，也记不得了，没啥好说的，&lt;/p&gt;
&lt;p&gt;第四题暴力过了80，不太想继续看了，出来了知道是树状数组板子题，记录一下&lt;/p&gt;
&lt;p&gt;大概题意：&lt;/p&gt;
&lt;p&gt;给两个长度都为 N 的数组 height 和 value ，分别表示每个人的高度和每个人的价值（身高都不一样&lt;/p&gt;
&lt;p&gt;求身高递增序列的最大价值&lt;/p&gt;
&lt;p&gt;问了rb，由于需要维护区间最值和单点修改，所以想到树状数组，&lt;/p&gt;
&lt;p&gt;写一下代码：&lt;/p&gt;
&lt;p&gt;（先记个TODO&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;solve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
  	
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/maximum-running-time-of-n-computers/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2141. 同时运行 N 台电脑的最长时间&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没思路，由于看到tag是二分，卡在如何根据电池情况计算最长时间&lt;/p&gt;
&lt;p&gt;其实有一个点是，如果时间是t，那么对于使用时间大于等于t的电池，只能给一个电脑用，因为t之后就结束了，&lt;/p&gt;
&lt;p&gt;想到这一点就离结论更近了：&lt;/p&gt;
&lt;p&gt;对于每一个电池，能提供的价值为min(电池容量，给定t)，&lt;/p&gt;
&lt;p&gt;check函数就很好写了&lt;/p&gt;
&lt;h2 id=&#34;424&#34;&gt;4.24&lt;/h2&gt;
&lt;p&gt;lc 93 改编，非数字可以当作任意数字使用，比如 10a1a02b3 可以是101.110.233&lt;/p&gt;
&lt;p&gt;当时思路是想让字母尽可能小（0），特殊情况是前导位就取1&lt;/p&gt;
&lt;p&gt;记个TODO&lt;/p&gt;
&lt;h2 id=&#34;429&#34;&gt;4.29&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1996. 游戏中弱角色的数量&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两个维度，一开始想的攻击升序防御降序然后遍历，但是这样会出现重复计算&lt;/p&gt;
&lt;p&gt;所以对攻击降序，防御升序，再维护一个之前防御的最大值，如果当前防御小于该值，则说明为弱角色（贪心&lt;/p&gt;
&lt;h2 id=&#34;430&#34;&gt;4.30&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;五一假期算开始了，这几天也有点时间刷题，不过应该不像清明那会从早刷到晚，大概率还是像以前那样上午+下午，感觉不错的话准备秋招期间也就还按着这个节奏和强度来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/longest-increasing-subsequence/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;300. 最长递增子序列&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/russian-doll-envelopes/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;354. 俄罗斯套娃信封问题&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;LIS问题，学习了nlogn的做法，核心思路是dp+二分，&lt;/p&gt;
&lt;p&gt;dp定义和n^2的定义不同，dp[i]是长度为i+1的子序列的尾部的值，&lt;/p&gt;
&lt;p&gt;因为这样才是有序的可以二分，&lt;/p&gt;
&lt;p&gt;需要注意left=res的时候才更新res&lt;/p&gt;
&lt;p&gt;354先根据一个升序再另一个降序就好了，之后对降序的维度计算LIS，&lt;/p&gt;
&lt;p&gt;降序是为了同一维度满足严格大于&lt;/p&gt;
&lt;p&gt;先刷一部分rollinghash + binarysearch tag的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/find-substring-with-given-hash-value/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2156. 查找给定哈希值的子串&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;算是rollinghash入门题了，但是不知道为什么一直超时&lt;/p&gt;
&lt;p&gt;换成群主的写法，倒着+每一步都取mod过了&lt;/p&gt;
&lt;h2 id=&#34;51&#34;&gt;5.1&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/count-unguarded-cells-in-the-grid/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;6053. 统计网格图中没有被保卫的格子数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比赛时候一直没有特别好的思路，&lt;/p&gt;
&lt;p&gt;实际上就是个模拟题，根据guard四个方向，碰到下一个guard break掉优化就好了，这样能保证是O(mn)的复杂度&lt;/p&gt;
&lt;p&gt;惨痛的教训&lt;/p&gt;
&lt;p&gt;该暴力就暴力&lt;/p&gt;
&lt;p&gt;像200这种数据量&lt;/p&gt;
&lt;p&gt;暴力就完事了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/escape-the-spreading-fire/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2258. 逃离火灾&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;又是个比赛没思路的题&lt;/p&gt;
&lt;p&gt;其实如果能想到二分时间就简单很多，&lt;/p&gt;
&lt;p&gt;以火为起点多元bfs，维护每个点被烧到的最短时间，&lt;/p&gt;
&lt;p&gt;check就行，注意check的时候维护visited，不然会超时&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1305. 两棵二叉搜索树中的所有元素&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还原数组+双指针就好了&lt;/p&gt;
&lt;h2 id=&#34;52&#34;&gt;5.2&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/longest-duplicate-substring/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1044. 最长重复子串&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前做过但是没a的题，再做一次，&lt;/p&gt;
&lt;p&gt;由于测试数据比较妖，所以check两次，并且MOD和POWER随机生成，&lt;/p&gt;
&lt;p&gt;MOD是[1e9+7, 1 &amp;laquo; 32]，POWER是[26, 30]&lt;/p&gt;
&lt;p&gt;即使这样还是有概率冲突，交了3次才过&lt;/p&gt;
&lt;h2 id=&#34;53&#34;&gt;5.3&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/longest-univalue-path/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;687. 最长同值路径&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;后序+左右相等时更新两侧但只返回大的一侧即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/sell-diminishing-valued-colored-balls/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1648. 销售价值减少的颜色球&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目意思很简单，也很容易想到二分，但是不容易写好&lt;/p&gt;
&lt;p&gt;tricky的点在于无法整除的情况下，是否要多拿一个补齐&lt;/p&gt;
&lt;p&gt;提交了挺多次都没过，也第一次让我认识到做一题不一定要一次过，&lt;/p&gt;
&lt;p&gt;后面找时间重写一下吧&lt;/p&gt;
&lt;p&gt;记个TODO&lt;/p&gt;
&lt;h2 id=&#34;54&#34;&gt;5.4&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1823. 找出游戏的获胜者&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;队列模拟/数学（约瑟夫环）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2049. 统计最高分的节点数目&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前做过的又不会了hhh&lt;/p&gt;
&lt;p&gt;想到一点，父节点方向的节点数可以通过总节点数 - 左 - 右 - 当前节点数算出来就很简单了，&lt;/p&gt;
&lt;p&gt;再注意下最小分数为1即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/ugly-number-iii/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;1201. 丑数 III&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;暴力超时，想到二分，思路是对的，但是不知道容斥原理&lt;/p&gt;
&lt;p&gt;知道了就很简单了，记录一下（以及求gcd和lcm）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;gcd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;# 记住小的在后面就行了&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gcd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;lcm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gcd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  
&lt;span class=&#34;c1&#34;&gt;# 容斥原理	&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# [1, n] 中能被 a, b, c整除的数个数&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;total&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lcm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lcm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lcm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lcm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;650了，也就是一个月大概只做了50题，相较于之前100题/月下降了一半，但是我感觉这样慢下来每一题多想想，是在付出的时间以及回报中得到一个比较好的平衡。高题量可能并不意味着高收获，质量是很重要的，其实任何事都是这个道理。&lt;/p&gt;
&lt;p&gt;最近各方面的节奏慢慢找回来了，希望自己能保持下去。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
